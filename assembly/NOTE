1.17 我真是服了 昨天的笔记 以及各种内容直接让我给关机了 什么都没了 大概一到三张的内容全没了

我这里就复述下我还记得的内容吧

-a修改指令
-r查看指令 或者修改操作指令  r cs   r ip
-t执行指令
-d查看数据
-e写入数据
-u查看对应的汇编指令

-e 1000：0 11 22 33 44
mov ax，1000
mov ds，ax
mov bx，[0]
操作后bx值为2211



栈 先入后出或者后入先出
push ax 将ax中的值推入栈中
pop ax 将栈顶指向的值赋给ax
栈操作都是16位即以字位单位

10000-1000f
栈顶一次移动两个16进制位
1b = 8bit 一个16进制位 16bit 即两个字节 一个字

栈溢出 即栈顶溢出 有两类 分别为
栈满后再执行push操作
栈空后执行pop操作

pop ax后栈顶sp只是不再指向该内存空间 但里面的数值依然存在！！！
只有再次进行push操作让新的值把它覆盖掉 否则数据不会消失
数据恢复就是类似原理 即便格式化 硬盘内的内容还是存在 只是盘符指向不一样了 没法通过简单的方法去访问
想要完全删除数据就是要不断的覆盖掉旧的内容
猜想类似回收站 删不删除影响不大 非常简单的知道即便文件放在回收站里 硬盘空间的可用还是不变的
！！！但是根据实践并非如此
！！！见pop值消失问题
！！！而且值还会改变 目前不知原因 哦可能是因为引用的地址空间并不是系统空闲地址 被拿去做其他的事情了  所以结论依然可能是对的 等待解答


以上是回忆内容 因为笔记丢失 能记得的都是第三章的内容 下次一定记住及时保存 开始学习

数据不能和短地址发生关系 所以要先把数据放入寄存器中 然后再赋值给段地址


push sp-2
取栈10000 1000f
sp始终指向栈空间 10000
sp指向栈顶
当栈为空 sp指向栈空间最高地址的下一个单位 即1000f+1=10010 这样执行push操作后才指向1000e 两个字节
1000e 1000f  数据为1000f 1000e

8086 0-ffff  64kb大小  2^16

所以把栈置空的话就要把sp指向栈空间最高地址的下一位
即MOV SP,10010

把一个寄存器置空时比如
MOV AX,0但是占用三个字节
SUB AX,AX 即用自己减去自己占用两个字节 从内存空间考虑 用sub更优
XOR异或 相同为0 不同为1  所以一样的 置零 XOR AX,AX 也是占用两个内存空间

栈先进后出的特性 出栈顺序要和入栈顺序相反 还是反复提醒一下
PUSH AX 
PUSH BX
SUB AX,AX
SUB BX,BX
POP BX
POP AX
记住每次操作sp 指向的空间永远是最低/最高地址的 2的倍数差值 因为栈每次传递一个字即两个字节
pop 后 sp+2


10000-1000f
这段内存称为栈段 但是cpu不知道 cpu只知道其中执行栈操作
栈段是人为定义 cpu无法理解 只由ss：sp控制



对ds中数据赋值时 不可以才用 MOV [FFF0],1313
数值要换成寄存器的地址才行

1000-ffff
这段空间64kb达到内存段最大大小  当栈为空的时候  sp理应指向最大地址空间ffff+1 即20000处
但此时内存空间达到最大 所以 sp变为0000
比如此时SS = 1000 SP = FFFE
POP AX  sp = 0000
POP BX  sp = 0002



第四章

编写 编译链接 执行

源程序
汇编指令-机器码-cpu
伪指令没有对应的机器码 不被cpu执行 是告诉编译器的

segement ends是一对成对使用的伪指令 成对出现
功能定义一个段

一个汇编程序由多个段组成 段用来存放代码 数据或当作栈空间使用
end结束 代表汇编结束  也是伪指令 编译器看到end 直接结束 注意区别ends
程序结尾必须有end否则无法结束

assume cs do
告诉编译器do只想代码寄存器

源程序文件-编译连接-可执行文件（16进制信息）


MOV AX,4C00
INT 21
程序返回

masm32当然不能直接编译连接16位程序 睿智吗 名字就看出来了 
需要在menu.INI文件中添加信息 然后调用文件执行

MASM 1.ASM
MASM 1.ASM;
加分号之后就没有各种让你确定的东西

ML 1.ASM
编译和连接 两步一起
编写
	1.asm 
编译
	1.obj
连接
	1.exe
cmd
	加载
内存中的程序 运行

cx寄存器存放代码长度


执行exe文件
	找到一段起始地址SA:0000 即偏移地址为0
	分为psp区和程序区
		psp SA:0
		程序区 SA+10H:0
			比如sa 04a0即ds为04a0
			那么内存空间就从04A0+10才是程序区
	psp区理解就好 dos和程序进行通信
	前256字节

p命令执行INT 21
	某种原因 XP+DOSBOX+MASM5.0环境无法使用p命令 报错 直接t命令也是PROGRAM TERMINATED NORMALLY


第五章
	1 [BX]
		DEBUG写汇编指令的时候
			MOV AX,[1] 是可以把ds中的值传给ax
			而用代码exe执行后 
				MOV AX,[1] 编译器把[1]当作数值1 就是给ax赋1
				
					所以编译器中的话用下面这种形式
					
						MOV BX,3
						MOV AX,[BX]
							这里就是代表ds的第三位地址指向的数据传给ax

			一定注意区别 干脆直接就忘了debug中的命令 不不不也不行 可能用得到 还是得记住
		复习一下
			ax传送的字  al传一个字节 因为al是ax的低位
	2 LOOP
		循环
			显然这个就是汇编中循环的指令
		两部操作
			(CX) = (CX) - 1
			判断CX 为0向下执行 否则转至标号处即退出循环
		通常loop实现循环 cx存放循环次数 这是规定 必须用cx
			cx本身存放的是程序大小
				之前应该写过了 还是记一下 后面这种情况就不重复了
			见5.asm
				写的时候有了一个问题 这个肯定前面就有解答 不过没有记得
					MOV CX,11 为什么cpu把它当做b 而不是0011 十进制的17处理呢
						很简单的问题。。。看下面结束语句不是有个
							MOV AX,4C00H
							后面加h的话就代表是16进制了啊。
							编译器默认把数当作10进制 所以要加h
				debug中loop 0006 ip 0008
					说明就是执行ip0006程序
				
		MOV AX,0FFFFH
			必须以0开头 否则错误
		
		123*321 add循环时应用321相加123次
			debug中肯定不能t 123 次 所以引入debug命令 g
				IP 0006
					ADD AX,AX
				IP 0008
					LOOP 0006
				使用g 0009
					直接执行完loop语句到达下一指令
			
			还有个p命令也可以 版本原因5.0没有
				用法是直接p就可
		
		
	tips：
		1
			(AX)=0010H
				AX中的内容为0010
				
			(21000H) = 0010H
				2000：1000中的内容为0010
				
			(AX) = ((DS) * 16 + 2)
				MOV AX,[2]
				
			((DS) * 16 + 2) = (AX)
				MOV [2],AX
					只是表达这个说法 实际上这个是不可行的语句？？存疑
						20.1.18.1.54更正 可以的
			
			(AX) = (AX) + 2
				ADD AX,2
				
			......看得懂没啥问题 就不往下写了
		
		2 idata
			MOV AX,[IDATA]
				MOV AX,1
				MOV AX,2
				MOV AX,3
		
		3 Inc dec
			INC INCREASE 4.asm
				INC AX = ADD AX,1
				DEC AX = SUB AX,1
					优点是占用内存更小
		
	3 DEBUG中跟踪用loop指令实现的循环程序
	4 DEBUG和masm对指令的不同处理
		MOV DS:[0H],AX
			MOV [0H],AX 编译器不识别
		
	5 loop和[BX]的联合应用
	6 段前缀
	7 一段安全的空间
		可能一段内存中有着系统或其他软件的代码数据 所以要有一个安全的空间
		
		dos方式下  0:200-0:2ff 这256个字节空间一般是没有系统内容的
			以后就是用这段空间就好了
		
	8段前缀的使用

	压缩就是改变文件的内部代码结构
		比如相片
			黑白的话 像素点1 黑 2 白
			三维的话 另一个参数 代表什么颜色
		压缩即优化 某种意义
		
	实验4.1
		一个非常简单但是忽略了的问题 自己写了代码才发现 顺便回忆前面丢失的笔记
		
			内存地址 = 段地址*16 + 偏移地址
			16 = 10H
				也就是说一个物理地址实际上有多种表达方法
				在做实验4.1第二题的时候忽略了这个严重的问题
				导致怎么也想不出来为什么可以9行
				
			比如题目的0:200H 如果不限制内存大小 那
				MOV AX,0
				MOV DS,AX
				MOV BX,200
			题目规定9行 所以这个物理地址是0*16 + 200H = 200h
				显然200h可以是
					20H:0
					2H:1E0H
				根据题目要求
				
				MOV AX,20H
				MOV DS,AX
				MOV BX,0
				
				如此一来就可以用bx本身控制偏移地址
					mov [bx],bl
				不需要ax也为0了 为了统一性就把错的放在这吧
					assume cs:cdsg

					cdsg segment

					start:
						mov ax,0
						mov ds,ax
						mov bx,200h
						mov cx,64
						
					s:
						mov [bx],ax
						inc ax
						inc bx
						loop s

						mov ax,4c00h
						int 21h
						
					cdsg ends

					end start
					
				正确的见9.asm
				
			

































