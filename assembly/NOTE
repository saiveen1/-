1.17 我真是服了 昨天的笔记 以及各种内容直接让我给关机了 什么都没了 大概一到三张的内容全没了

我这里就复述下我还记得的内容吧

-a修改指令
-r查看指令 或者修改操作指令  r cs   r ip
-t执行指令
-d查看数据
-e写入数据
-u查看对应的汇编指令

-e 1000：0 11 22 33 44
mov ax，1000
mov ds，ax
mov bx，[0]
操作后bx值为2211



栈 先入后出或者后入先出
push ax 将ax中的值推入栈中
pop ax 将栈顶指向的值赋给ax
栈操作都是16位即以字位单位

10000-1000f
栈顶一次移动两个16进制位
1b = 8bit 一个16进制位 16bit 即两个字节 一个字

栈溢出 即栈顶溢出 有两类 分别为
栈满后再执行push操作
栈空后执行pop操作

pop ax后栈顶sp只是不再指向该内存空间 但里面的数值依然存在！！！
只有再次进行push操作让新的值把它覆盖掉 否则数据不会消失
数据恢复就是类似原理 即便格式化 硬盘内的内容还是存在 只是盘符指向不一样了 没法通过简单的方法去访问
想要完全删除数据就是要不断的覆盖掉旧的内容
猜想类似回收站 删不删除影响不大 非常简单的知道即便文件放在回收站里 硬盘空间的可用还是不变的
！！！但是根据实践并非如此
！！！见pop值消失问题
！！！而且值还会改变 目前不知原因 哦可能是因为引用的地址空间并不是系统空闲地址 被拿去做其他的事情了  所以结论依然可能是对的 等待解答


以上是回忆内容 因为笔记丢失 能记得的都是第三章的内容 下次一定记住及时保存 开始学习

数据不能和短地址发生关系 所以要先把数据放入寄存器中 然后再赋值给段地址


push sp-2
取栈10000 1000f
sp始终指向栈空间 10000
sp指向栈顶
当栈为空 sp指向栈空间最高地址的下一个单位 即1000f+1=10010 这样执行push操作后才指向1000e 两个字节
1000e 1000f  数据为1000f 1000e

8086 0-ffff  64kb大小  2^16

所以把栈置空的话就要把sp指向栈空间最高地址的下一位
即MOV SP,10010

把一个寄存器置空时比如
MOV AX,0但是占用三个字节
SUB AX,AX 即用自己减去自己占用两个字节 从内存空间考虑 用sub更优
XOR异或 相同为0 不同为1  所以一样的 置零 XOR AX,AX 也是占用两个内存空间

栈先进后出的特性 出栈顺序要和入栈顺序相反 还是反复提醒一下
PUSH AX 
PUSH BX
SUB AX,AX
SUB BX,BX
POP BX
POP AX
记住每次操作sp 指向的空间永远是最低/最高地址的 2的倍数差值 因为栈每次传递一个字即两个字节
pop 后 sp+2


10000-1000f
这段内存称为栈段 但是cpu不知道 cpu只知道其中执行栈操作
栈段是人为定义 cpu无法理解 只由ss：sp控制



对ds中数据赋值时 不可以才用 MOV [FFF0],1313
数值要换成寄存器的地址才行

1000-ffff
这段空间64kb达到内存段最大大小  当栈为空的时候  sp理应指向最大地址空间ffff+1 即20000处
但此时内存空间达到最大 所以 sp变为0000
比如此时SS = 1000 SP = FFFE
POP AX  sp = 0000
POP BX  sp = 0002



第四章

编写 编译链接 执行

源程序
汇编指令-机器码-cpu
伪指令没有对应的机器码 不被cpu执行 是告诉编译器的

segement ends是一对成对使用的伪指令 成对出现
功能定义一个段

一个汇编程序由多个段组成 段用来存放代码 数据或当作栈空间使用
end结束 代表汇编结束  也是伪指令 编译器看到end 直接结束 注意区别ends
程序结尾必须有end否则无法结束

assume cs do
告诉编译器do只想代码寄存器

源程序文件-编译连接-可执行文件（16进制信息）


MOV AX,4C00
INT 21
程序返回

masm32当然不能直接编译连接16位程序 睿智吗 名字就看出来了 
需要在menu.INI文件中添加信息 然后调用文件执行

MASM 1.ASM
MASM 1.ASM;
加分号之后就没有各种让你确定的东西

ML 1.ASM
编译和连接 两步一起
编写
	1.asm 
编译
	1.obj
连接
	1.exe
cmd
	加载
内存中的程序 运行

cx寄存器存放代码长度


执行exe文件
	找到一段起始地址SA:0000 即偏移地址为0
	分为psp区和程序区
		psp SA:0
		程序区 SA+10H:0
			比如sa 04a0即ds为04a0
			那么内存空间就从04A0+10才是程序区
	psp区理解就好 dos和程序进行通信
	前256字节

p命令执行INT 21
	XP+DOSBOX+MASM5.0环境无法使用p命令 报错 直接t命令也是PROGRAM TERMINATED NORMALLY


第五章
	1 [BX]
		DEBUG写汇编指令的时候
			MOV AX,[1] 是可以把ds中的值传给ax
			而用代码exe执行后 
				MOV AX,[1] 编译器把[1]当作数值1 就是给ax赋1
				
					所以编译器中的话用下面这种形式
					
						MOV BX,3
						MOV AX,[BX]
							这里就是代表ds的第三位地址指向的数据传给ax

			一定注意区别 干脆直接就忘了debug中的命令 不不不也不行 可能用得到 还是得记住
		复习一下
			ax传送的字  al传一个字节 因为al是ax的低位
	2 LOOP
		循环
			显然这个就是汇编中循环的指令
		两部操作
			(CX) = (CX) - 1
			判断CX 为0向下执行 否则转至标号处即退出循环
		通常loop实现循环 cx存放循环次数 这是规定 必须用cx
			cx本身存放的是程序大小
				之前应该写过了 还是记一下 后面这种情况就不重复了
			见5.asm
				写的时候有了一个问题 这个肯定前面就有解答 不过没有记得
					MOV CX,11 为什么cpu把它当做b 而不是0011 十进制的17处理呢
						很简单的问题。。。看下面结束语句不是有个
							MOV AX,4C00H
							后面加h的话就代表是16进制了啊。
							编译器默认把数当作10进制 所以要加h
				debug中loop 0006 ip 0008
					说明就是执行ip0006程序
				
		MOV AX,0FFFFH
			必须以0开头 否则错误
		
		123*321 add循环时应用321相加123次
			debug中肯定不能t 123 次 所以引入debug命令 g
				IP 0006
					ADD AX,AX
				IP 0008
					LOOP 0006
				使用g 0009
					直接执行完loop语句到达下一指令
			
			还有个p命令也可以 版本原因5.0没有
				用法是直接p就可
		
		
	tips：
		1
			(AX)=0010H
				AX中的内容为0010
				
			(21000H) = 0010H
				2000：1000中的内容为0010
				
			(AX) = ((DS) * 16 + 2)
				MOV AX,[2]
				
			((DS) * 16 + 2) = (AX)
				MOV [2],AX
					只是表达这个说法 实际上这个是不可行的语句？？存疑
						20.1.18.1.54更正 可以的
			
			(AX) = (AX) + 2
				ADD AX,2
				
			......看得懂没啥问题 就不往下写了
		
		2 idata
			MOV AX,[IDATA]
				MOV AX,1
				MOV AX,2
				MOV AX,3
		
		3 Inc dec
			INC INCREASE 4.asm
				INC AX = ADD AX,1
				DEC AX = SUB AX,1
					优点是占用内存更小
		
	3 DEBUG中跟踪用loop指令实现的循环程序
	4 DEBUG和masm对指令的不同处理
		MOV DS:[0H],AX
			MOV [0H],AX 编译器不识别
		
	5 loop和[BX]的联合应用
	6 段前缀
	7 一段安全的空间
		可能一段内存中有着系统或其他软件的代码数据 所以要有一个安全的空间
		
		dos方式下  0:200-0:2ff 这256个字节空间一般是没有系统内容的
			以后就是用这段空间就好了
		
	8段前缀的使用

	压缩就是改变文件的内部代码结构
		比如相片
			黑白的话 像素点1 黑 2 白
			三维的话 另一个参数 代表什么颜色
		压缩即优化 某种意义
		
	实验4.1
		一个非常简单但是忽略了的问题 自己写了代码才发现 顺便回忆前面丢失的笔记
		
			内存地址 = 段地址*16 + 偏移地址
			16 = 10H
				也就是说一个物理地址实际上有多种表达方法
				在做实验4.1第二题的时候忽略了这个严重的问题
				导致怎么也想不出来为什么可以9行
				
			比如题目的0:200H 如果不限制内存大小 那
				MOV AX,0
				MOV DS,AX
				MOV BX,200
			题目规定9行 所以这个物理地址是0*16 + 200H = 200h
				显然200h可以是
					20H:0
					2H:1E0H
				根据题目要求
				
				MOV AX,20H
				MOV DS,AX
				MOV BX,0
				
				如此一来就可以用bx本身控制偏移地址
					mov [bx],bl
				不需要ax也为0了 为了统一性就把错的放在这吧
					assume cs:cdsg

					cdsg segment

					start:
						mov ax,0
						mov ds,ax
						mov bx,200h
						mov cx,64
						
					s:
						mov [bx],ax
						inc ax
						inc bx
						loop s

						mov ax,4c00h
						int 21h
						
					cdsg ends

					end start
					
				正确的见9.asm
			用意应该就是让回忆起这个知识点 以后灵活应用
			
			好处是可以节省空间 但不符合常理
			

6.1
代码段中使用数据
	dw define word
		定义字型数据
			定义八个字型数据 数据之间逗号隔开
	db define byte
		定义字节数据
			递增1

	程序11 计算存放在cs中8个数据的和 结果放在ax寄存器中
		由于存储在cs中 cpu默认把其中的数据识别为代码指令  
			这个时候就要添加入口 把代码入口添加在真正的指令后面
					dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
					mov bx,0
					
					应改为
					dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
			start：	mov bx,0


代码段中使用数据
	dw写在codesg即cs段中 所以数据存储在cs

要求用栈传输数据
	push [bx]
	mov cs[bx],bx
	显然脑瘫了这里
	应该
	
	push [bx]
	pop cs[bx]

不同的段
	ASSUME CS:CODE,DS:DATE,SS:STACK
	
	END START实际上是入口 程序被加载后CS:IP由这里执行start的代码
	
	
将近一个小时 不知道什么原因 估计也不可能知道了。。。。。。。。 
	extra characters on line
	missing or unreachable cs
怎么改都不行 然后原封不动复制到新的文件 竟然就可以了。。。。。。？？？？？？什么操作 浪费了相当长时间
也敲响警钟 下次遇到这种情况要考虑此种 谨记！

dw db
	1 2 3 4 5 6
		dw 01 00 02 00 03 00
		db 01 02 03 04

声明段 通过自己亲自写16asm才暴露出一堆问题
	首先这个声明段 assume只是在你cs段给定栈地址时里面的数值为多少
		告诉编译器我要往这里面填入这些值
	所以 总的来说 无论是数据段 还是栈段地址 都需要人为的去操作
	
	16asm debug发现栈中数据确实为 abd中数据 但是没有使用assume声明
			然后c不能用作标记符 故abd
			经实践 加不加对程序并无造成影响
			
			如果MOV AX,B
			debug中为 MOV AX,04B1
			也就是说 段地址中的写入的值在
				04AF即栈寄存器地址的后一位
				04B0存放 abd
				04B1存放 bd
				04B2存放 d
				而栈寄存器由于栈的特性DBA
				
	16asm中对于dw db的操作包括前面也没有在意 现在逐一分析 一定弄懂 彻底
		MOV AX,A
		debug中为    MOV AX,04B0
		实际栈地址为04AF
			根据其中数据可以知道栈地址中存放的就是A B D的数据
			而04B0的顺序却为
				123...
				123...
				000...	
			与栈中完全相反
		接着执行
		MOV DS,AX
			此时ds中数据与上步相同
			一直执行到循环为止都没有进行各段地址的改动
		如答案要求相加两个段地址中的值 这里也引入了一个新的写法
		在此需要注意的是！！！！
			db即便一次写入一个字节 但是总共占用的地址还是16位！！！
			这里一定记住
		所以04B0中的值排列
			04b0:0
			04b0:10
			04b0:20
		新写法如下
		ADD AL,[BX+10]非常容易理解
		再后是AL由于生疏根本没想到al的应用 如果使用ax那就大错特错
			显然传值为0201 0403此类
				[0] 0201
				[2] 0
		
		最后将al传入[BX+20]完成要求
		这是课本答案
		
		16c作为自己的思考
			寄存器间接寻址时 只能使用 BX, BP, SI, DI 
		
			LINE23已经说明了栈操作都是以字为单位的
		
			由于栈的逆序性应该先传后面的值
				比如一组数12345....依次入栈 体现为数据正序时
				应当54321如栈顶0 此时sp指向1
			因为使用栈操作 不可避免的以字为单位
				各方面都要考虑到sp为8 而数据段起始地址应当为6
					因为偏移地址计算当前两个字节
				循环地址四次
		结合书本的答案和自己的答案
			欠缺经验 同样的答案自己写的就耗费27个字节
			没有融会贯通 高地位的操作更是没有想到
			
			书本的答案更加直观容易理解 但是也不容易想到
			其中[BX+10H]的操作更是节省掉一个寄存器的内存
			也不要看到栈就想pop push
	
		
	











